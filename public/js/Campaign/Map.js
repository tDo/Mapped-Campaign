/*
    This file defines the default projection and setup for the map.
    This includes tile retrieval for specific zoom levels and locations
    as well as caching tiles for usage.

    The tiles are created using the GMap Image Cutter
*/

var Campaign = Campaign || {};

/** 
 * A projection class which projects the world coordinates to a
 * 0,0 => 50, 50 system unlike real world coordinates. This allows
 * for a better understanding of world positions as well as placement
 * and distance calculations
 */
Campaign.FiftyProjection = function () {
    // Pixel size of tile at zoom level 1
    var max = 256;

    // Map latitude to point. We define a 0,0 to 50,50 coordinate system
    // this means that the upper left corner of the map is at 0,0 while the
    // bottom right corner is at 50,50. This allows us to easily convert those
    // values to better coordinates on our map...
    this.fromLatLngToPoint = function(latlng) {
        var x = max * latlng.lng() / 50;
        var y = max * latlng.lat() / 50;

        return new google.maps.Point(x, y);
    }

    this.fromPointToLatLng = function(pixel) {
        // inverse conversion
        var lng = pixel.x / max * 50;
        var lat = pixel.y / max * 50;
        return new google.maps.LatLng(lat, lng);
    };
}

/**
 * Custom map type used to cache, retrieve and handle the custom tiles
 * generated by GMapImageCutter tool
 * @param {String} tilesPath Path were the tiles are stored for this map
 */
Campaign.CustomMapType = function(tilesPath) {
    this.cache     = Array();
    this.opacity   = 1.0;
    this.tilesPath = tilesPath;

    // name of the map type
    this.name      = "Map";
    this.alt       = "Map Tiles";

    // Set tile size to 256x256 px (Default for google maps, so we won't change that)
    this.tileSize = new google.maps.Size(256, 256);
    // Maximum zoom level would be 19
    this.maxZoom  = 19;

    // Reference to self for context holding
    var self = this;

    // Replacement method which converts coordinates to the tiles being rendered
    this.getTile = function(coord, zoom, ownerDocument) {
        var c = Math.pow(2, zoom);
        var tilex = coord.x, tiley = coord.y;

        if ((tilex < 0) || (tilex >= c) || (tiley < 0) || (tiley >= c)) {
            var blank          = ownerDocument.createElement('div');
            blank.style.width  = self.tileSize.width  + 'px';
            blank.style.height = self.tileSize.height + 'px';
            return blank;
        }

        var img = ownerDocument.createElement('img');
        var d = tilex, e = tiley, f = "t";
        for (var g = 0; g < zoom; g++) {
            c /= 2;
            if (e < c) {
                if (d < c) { f += "q" }
                else { f += "r"; d -= c }
            }
            else {
                if (d < c) { f += "t"; e -= c }
                else { f += "s"; d -= c; e -= c }
            }
        }
        img.id           = "t_" + f;
        img.style.width  = self.tileSize.width + 'px';
        img.style.height = self.tileSize.height + 'px';
        //img.src          = "Images/Map/Overworld/"+ f +".jpg";
        img.src          = self.tilesPath + f +".jpg";
        self.cache.push(img);
        return img;
    }

    // Will free a tile, remove it from memory and cache
    this.realeaseTile = function(tile) {
        var idx = self.cache.indexOf(tile);
        if(idx != -1) self.cache.splice(idx, 1);
        tile    = null;
    }

    // Function used to set the opacity for the cached tiles
    this.setOpacity = function(newOpacity) {
        self.opacity = newOpacity;
        var cl = this.Cache.length;
        for (var i = 0; i < cl; i++) {
            self.cache[i].style.opacity = newOpacity; //mozilla
            self.cache[i].style.filter  = "alpha(opacity=" + newOpacity * 100 + ")"; //ie
        }
    }
}

/**
 * Map wrapper which handles the whole initialization process and custom
 * handling of the map itsself like boundary checks, container resizing, map type
 * assignment and projection assignment. Just provide the id of the map from database
 * as well as a container element in the dom and create a new instance of the class
 *
 * @param {Integer}    mapId             Id of the map (As stored in the database)
 * @param {String}     mapContainerDomId DOM-Element id of the map container
 * @param {Boolean}    allowEditing      Wether the editor shall be enabled or not
 */
Campaign.Map = function(mapId, mapContainerDomId, allowEditing) {
    // Reference to self for context
    var self = this;

    // Reference to the id of the map (As defined in database)
    this.mapId = mapId;
    // Set the map container id for internal reference
    this.mapContainerDomId = mapContainerDomId;

    // Small helper function to retrieve the window height
    this.getWindowHeight = function() {
        if (window.self && self.innerHeight)
            return self.innerHeight;
        if (document.documentElement && document.documentElement.clientHeight)
            return document.documentElement.clientHeight;
        return 0;
    }

    // helper function to resize the map container
    this.resizeMapContainer = function() {
        //Do not call any map methods here as the resize is called before the map is created.
        var d = document.getElementById(self.mapContainerDomId);

        var offsetTop = 0;
        for (var elem = d; elem != null; elem = elem.offsetParent)
            offsetTop += elem.offsetTop;

        var height = self.getWindowHeight() - offsetTop - 16;

        if (height >= 0)
            d.style.height = height +"px";
    }

    // Helper function which will make sure that the map stays in the possible
    // bounds and can not be dragged out of it
    this.checkBounds = function() {    
        if(!self.allowedBounds.contains(self.map.getCenter())) {
          var C = self.map.getCenter();
          var X = C.lng();
          var Y = C.lat();

          var AmaxX = self.allowedBounds.getNorthEast().lng();
          var AmaxY = self.allowedBounds.getNorthEast().lat();
          var AminX = self.allowedBounds.getSouthWest().lng();
          var AminY = self.allowedBounds.getSouthWest().lat();

          if (X < AminX) {X = AminX;}
          if (X > AmaxX) {X = AmaxX;}
          if (Y < AminY) {Y = AminY;}
          if (Y > AmaxY) {Y = AmaxY;}

          self.map.setCenter(new google.maps.LatLng(Y,X));
        }
    }

    // Bind window resize to map resize event
    $(window).resize(function() { self.resizeMapContainer(); });

    // And resize the map container beforehand
    this.resizeMapContainer();

    // Defines the options used for this map
    var mapOptions = {
        zoom:                  2,                                  // Initial zoom at 2
        minZoom:               0,                                  // Minimum zoom to level 2
        maxZoom:               5,
        center:                new google.maps.LatLng(25.0, 25.0), // Center as defined by our fifty projection
        panControl:            true,
        zoomControl:           true,
        mapTypeControl:        false,
        scaleControl:          false,
        streetViewControl:     false,
        overviewMapControl:    true,
        mapTypeControlOptions: { mapTypeIds: ["CustomMap"] },
        mapTypeId:             "CustomMap"
    }

    // Initialize the actual map
    this.map       = new google.maps.Map(document.getElementById(mapContainerDomId), mapOptions);

    // Add the editor (If editing is allowed)
    if (allowEditing) this.editor = new Campaign.Editor(self);

    // Create the districts instance
    this.districts = new Campaign.Districts(this);
    // and the locations instance
    this.locations = new Campaign.Locations(this);

    // Do a map retrieval callback via jquery ajax call and then handle the returned data
    // by filling up the map.
    $.get('map/'+ mapId, function(data) {
        // Could not retrieve the path...
        if (data.path == undefined) return;

        // Create the custom map type and apply our projection
        var cMap        = new Campaign.CustomMapType('img/maps/'+ data.path +'/');
        cMap.projection = new Campaign.FiftyProjection();

        // And set is as the map type
        self.map.mapTypes.set("CustomMap", cMap);

        // Retrieve sub-elements
        if (data.regions != undefined) {
            $.each(data.regions, function(ireg, region) {
                // And also handle the districts
                if (region.districts != undefined)
                    $.each(region.districts, function(idis, district) {
                        // Add the district to the map
                        self.districts.add(district);
                        // And handle the locations for this district
                        if (district.locations != undefined)
                            $.each(district.locations, function(iloc, location) {
                                // Add the location to the map
                                self.locations.add(district.id, location);
                            });
                    });
            });
        }

        //google.maps.event.addListener(map, 'click', function(event) {
            //alert(event.latLng)
        //});
        
        // Update allowed bounds on idle
        google.maps.event.addListenerOnce(self.map, 'idle', function() {
            self.allowedBounds = self.map.getBounds();
        });

        // And bind the center changed event to the bounds check to keep the map in place
        google.maps.event.addListener(self.map, 'center_changed', function() { self.checkBounds(); });
        
    }, 'json');
}